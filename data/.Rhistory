#while (i <= n_lnr) {
L_new  <- PC_segment_4(lnr)
P <- L_new[[1]]
n_P <- L_new[[2]]
P <- P[1:n_P,]
P <- as.data.frame(P)
names(P) <- c("idx","x","y")
P_red <- reduce_pointset(P) #new
head(P_red)
x_m <- mean(P_red[,2])
y_m <- mean(P_red[,3]) #change to math-system
points(P[,2]-orig_x,(P[,3]-orig_y), pch=".", asp=1, cex=2.0, col="red") #see 'Plots' (plot))
points(P_red[,2]-orig_x,(P_red[,3]-orig_y), pch=".", asp=1, cex=2.0, col="black") #see 'Plots' (plot)
points(x_m-orig_x, y_m-orig_y, pch=16, asp=1, cex=2.0, col="blue")
##plot of lines
lnr <- readline("type line number: ")
lnr <- as.integer(lnr)
n_lnr <- lnr #lnr_ref must be smaller than 10 (otherwise: change n_lnr)
#loop
#while (i <= n_lnr) {
L_new  <- PC_segment_4(lnr)
P <- L_new[[1]]
n_P <- L_new[[2]]
P <- P[1:n_P,]
P <- as.data.frame(P)
names(P) <- c("idx","x","y")
P_red <- reduce_pointset(P) #new
head(P_red)
x_m <- mean(P_red[,2])
y_m <- mean(P_red[,3]) #change to math-system
points(P[,2]-orig_x,(P[,3]-orig_y), pch=".", asp=1, cex=2.0, col="red") #see 'Plots' (plot))
points(P_red[,2]-orig_x,(P_red[,3]-orig_y), pch=".", asp=1, cex=2.0, col="black") #see 'Plots' (plot)
points(x_m-orig_x, y_m-orig_y, pch=16, asp=1, cex=2.0, col="blue")
#plot of ref-line of Hough trans results onto graph (math-system)
theta_math <- 180 - B4$theta_angle[lnr]
#theta_math <- 360 - B4$theta_angle[lnr_ref]
cat("theta_math= ", theta_math,"\n")
a <- -1/tan(theta_math/omega)
cat("a=",a,"\n")
x <- x_m
y <- y_m
p2 <- round(x*cos(theta_math/omega) + y*sin(theta_math/omega))
b <- round(p2/sin(theta_math/omega))
cat("b= ", b, "\n")
coef = c(b,a)
#calculation of intercept (b2) at image extract
orig_y_math <- (-orig_y) #change to math-system
b_math <- (-b)
y1 <- a * orig_x + b_math
b2_math <- y1 - orig_y_math
cat("b2_math=", b2_math, "\n")
#change to image-system
b2_img <- round(-b2_math)
a_img <- (-a)
coef2 <- c(b2_img,a_img)
if (is.finite(a)) {
abline(coef2, col="green", lty=1, lwd=2, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="yellow",lty=1,lwd=2,asp=1)
}
B4$ro_pixel[lnr]
lnr
wind_y-orig_y
ro_l1 - orig_x
wind_y
orig_y
ro_l3
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="yellow",lty=1,lwd=2,asp=1)
if (is.finite(a_img)) {
abline(coef2, col="green", lty=1, lwd=2, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=2,asp=1)
}
a_img
if (is.finite(a_img) || is.finite(b2_img)) {
abline(coef2, col="green", lty=1, lwd=2, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=2,asp=1)
}
is.finite(a_img) || is.finite(b2_img)
?abline
a_img
b2_img
a_img
if (is.finite(a_img) || is.finite(b2_img)) {
abline(coef2, col="black", lty=1, lwd=2, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=2,asp=1)
}
ro_l3
lnr
B4$ro_pixel[lnr]
orig_x
#calculation of intercept (b2) at image extract
orig_y_math <- (-orig_y) #change to math-system
b_math <- (-b)
y1 <- a * orig_x + b_math
b2_math <- y1 - orig_y_math
cat("b2_math=", b2_math, "\n")
#change to image-system
b2_img <- round(-b2_math)
b2_img
a_img <- (-a)
a_img
coef2 <- c(b2_img,a_img)
if (is.finite(a_img) || is.finite(b2_img)) {
abline(coef2, col="black", lty=1, lwd=2, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=2,asp=1)
}
if (is.finite(a_img) && is.finite(b2_img)) {
abline(coef2, col="black", lty=1, lwd=3, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=3,asp=1)
}
dir_meas <- locator(2)
x_ang <- (dir_meas$y[1] - dir_meas$y[2]) / (dir_meas$x[1] - dir_meas$x[2])
dir_meas <- locator(2)
x_ang <- (dir_meas$y[1] - dir_meas$y[2]) / (dir_meas$x[1] - dir_meas$x[2])
alpha_meas <- atan(x_ang) * omega
alpha_math <- (-alpha_meas) #change to math-system
theta_math <- alpha_math + 90
theta_img <- (-theta_math) #change to img-system
if(theta_img < 0) {
theta_img <- theta_img + 180
}
theta_ind <- round(theta_img / 5) + 1
theta_ind # theta_ind > 0 ?
if (theta_ind < 0) {
theta_ind <- theta_ind + 18
}
cat("theta_ind=", theta_ind, "\n")
alph_ind1 <- theta_ind + 90/5
cat("alph_ind1=", alph_ind1, "\n")
alph_ind2 <- theta_ind - 90/5 #theta_ind2 > 0 ?
cat("alph_ind2=", alph_ind2, "\n")
theta_ind2 <- alph_ind2 - 90/5 #theta_ind2 > 0 ?
cat("theta_ind2=", theta_ind2, "\n")
## 3.search of lines (lnr) with theta_index and plot of line
theta_ind <- readline("type theta_index= ")
## 3.search of lines (lnr) with theta_index and plot of line
theta_ind <- readline("type theta_index= ")
theta_ind <- as.integer(theta_ind)
vec <- 1 : length(B2[,1])
for (i in vec) {
if (B2[i,2] == theta_ind && B2[i,4]/kf > n_pix) { #kf=scale factor
print(B2[i, ])
}
} #end search of lines with theta_index
##search of lines (lnr) with alph_index
alph_ind <- theta_ind2 + 18
vec <- 1 : length(B2[,1])
for (i in vec) {
if (B2[i,2] == alph_ind) {
cat("lnr= ",i,"\n")
}
} #end search of lines with alph_index
for (i in vec) {
if (B2[i,2] == alph_ind2) {
cat("lnr= ",i,"\n")
print(B2[i, ])
}
} #end search of lines with alph_index2
## 3.search of lines (lnr) with theta_index and plot of line
theta_ind <- readline("type theta_index= ")
theta_ind <- as.integer(theta_ind)
vec <- 1 : length(B2[,1])
for (i in vec) {
if (B2[i,2] == theta_ind && B2[i,4]/kf > n_pix) { #kf=scale factor
print(B2[i, ])
}
} #end search of lines with theta_index
##search of lines (lnr) with alph_index
alph_ind <- theta_ind2 + 18
vec <- 1 : length(B2[,1])
for (i in vec) {
if (B2[i,2] == alph_ind) {
cat("lnr= ",i,"\n")
}
} #end search of lines with alph_index
for (i in vec) {
if (B2[i,2] == alph_ind2) {
cat("lnr= ",i,"\n")
print(B2[i, ])
}
} #end search of lines with alph_index2
## 3.search of lines (lnr) with theta_index and plot of line
theta_ind <- readline("type theta_index= ")
theta_ind <- as.integer(theta_ind)
vec <- 1 : length(B2[,1])
for (i in vec) {
if (B2[i,2] == theta_ind && B2[i,4]/kf > n_pix) { #kf=scale factor
print(B2[i, ])
}
} #end search of lines with theta_index
##search of lines (lnr) with alph_index
alph_ind <- theta_ind + 18
vec <- 1 : length(B2[,1])
for (i in vec) {
if (B2[i,2] == alph_ind) {
cat("lnr= ",i,"\n")
}
} #end search of lines with alph_index
for (i in vec) {
if (B2[i,2] == alph_ind) {
cat("lnr= ",i,"\n")
}
} #end search of lines with alph_index
for (i in vec) {
if (B2[i,2] == alph_ind) {
cat("lnr= ",i,"\n")
print(B2[i, ])
}
} #end search of lines with alph_index2
##plot of lines
lnr <- readline("type line number: ")
lnr <- as.integer(lnr)
n_lnr <- lnr #lnr_ref must be smaller than 10 (otherwise: change n_lnr)
#loop
#while (i <= n_lnr) {
L_new  <- PC_segment_4(lnr)
P <- L_new[[1]]
n_P <- L_new[[2]]
P <- P[1:n_P,]
P <- as.data.frame(P)
names(P) <- c("idx","x","y")
P_red <- reduce_pointset(P) #new
head(P_red)
x_m <- mean(P_red[,2])
y_m <- mean(P_red[,3]) #change to math-system
points(P[,2]-orig_x,(P[,3]-orig_y), pch=".", asp=1, cex=2.0, col="red") #see 'Plots' (plot))
points(P_red[,2]-orig_x,(P_red[,3]-orig_y), pch=".", asp=1, cex=2.0, col="black") #see 'Plots' (plot)
points(x_m-orig_x, y_m-orig_y, pch=16, asp=1, cex=2.0, col="blue")
#plot of ref-line of Hough trans results onto graph (math-system)
theta_math <- 180 - B4$theta_angle[lnr]
#theta_math <- 360 - B4$theta_angle[lnr_ref]
cat("theta_math= ", theta_math,"\n")
a <- -1/tan(theta_math/omega)
cat("a=",a,"\n")
x <- x_m
y <- y_m
p2 <- round(x*cos(theta_math/omega) + y*sin(theta_math/omega))
b <- round(p2/sin(theta_math/omega))
cat("b= ", b, "\n")
coef = c(b,a)
#calculation of intercept (b2) at image extract
orig_y_math <- (-orig_y) #change to math-system
b_math <- (-b)
y1 <- a * orig_x + b_math
b2_math <- y1 - orig_y_math
cat("b2_math=", b2_math, "\n")
#change to image-system
b2_img <- round(-b2_math)
b2_img
a_img <- (-a)
a_img
coef2 <- c(b2_img,a_img)
if (is.finite(a_img) && is.finite(b2_img)) {
abline(coef2, col="black", lty=1, lwd=3, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=3,asp=1)
}
B4
b2_img
a_img
a
b2_img
abline(coef2, col="black", lty=1, lwd=3, asp=1)
abline(coef2, col="blue", lty=1, lwd=3, asp=1)
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=3,asp=1)
coef2 <- c(b2_img,a_img)
abline(coef2, col="blue", lty=1, lwd=3, asp=1)
B4$theta_angle[lnr]
theta_math
theta_math <- theta_math -180
#theta_math <- 360 - B4$theta_angle[lnr_ref]
cat("theta_math= ", theta_math,"\n")
a <- -1/tan(theta_math/omega)
cat("a=",a,"\n")
x <- x_m
y <- y_m
p2 <- round(x*cos(theta_math/omega) + y*sin(theta_math/omega))
b <- round(p2/sin(theta_math/omega))
cat("b= ", b, "\n")
coef = c(b,a)
#calculation of intercept (b2) at image extract
orig_y_math <- (-orig_y) #change to math-system
b_math <- (-b)
y1 <- a * orig_x + b_math
b2_math <- y1 - orig_y_math
cat("b2_math=", b2_math, "\n")
#change to image-system
b2_img <- round(-b2_math)
b2_img
a_img <- (-a)
a_img
coef2 <- c(b2_img,a_img)
if (is.finite(a_img) && is.finite(b2_img)) {
abline(coef2, col="blue", lty=1, lwd=3, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=3,asp=1)
}
a_img
coef2 <- c(b2_img,a_img)
if (is.finite(a_img) && is.finite(b2_img)) {
abline(coef2, col="blue", lty=1, lwd=3, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=3,asp=1)
}
is.finite(a_img) && is.finite(b2_img
is.finite(a_img) && is.finite(b2_img)
B4$ro_pixel[lnr]
ro_l3
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="blue",lty=1,lwd=3,asp=1)
theta_math
#calculation of intercept (b2) at image extract
orig_y_math <- (-orig_y) #change to math-system
b_math <- (-b)
y1 <- a * orig_x + b_math
b2_math <- y1 - orig_y_math
cat("b2_math=", b2_math, "\n")
#change to image-system
b2_img <- round(-b2_math)
b2_img
a_img <- (-a)
a_img
coef2 <- c(b2_img,a_img)
if (is.finite(a_img) && is.finite(b2_img)) {
abline(coef2, col="blue", lty=1, lwd=3, asp=1)
} else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l3 <- round(ro_l1 - orig_x)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="blue",lty=1,lwd=3,asp=1)
}
alpha_img <- (-alpha_math)
lines(c(ro_l3,ro_l3),c(0,wind_y-orig_y),col="red",lty=1,lwd=3,asp=1)
cat("theta_math= ", theta_math,"\n")
a <- -1/tan(theta_math/omega)
cat("a=",a,"\n")
x <- x_m
y <- y_m
p2 <- round(x*cos(theta_math/omega) + y*sin(theta_math/omega))
b <- round(p2/sin(theta_math/omega))
cat("b= ", b, "\n")
coef = c(b,a)
#plot onto graph
if(is.finite(a)) {
abline(coef, col="red", lty=1, lwd=2, asp=1) #ref line
} else {
ro_l1 <- B4$ro_pixel[lnr] #changed
#ro_l2 <- ro_l1+ro_1
lines(c(ro_l1,ro_l1),c(0,-2569),col="red",lty=1,lwd=2,asp=1) #(ISPRS1), ref/th1
lines(c(ro_l1,ro_l1),c(0,1919),col="red",lty=1,lwd=2,asp=1) #(ISPRS1), orth/th2
} # end of plotting reference-line
#search for parallel and orthogonal lines based on reference line (ref)
#select ref line, usually the first (longest) line
#joint search for parallel and orthogonal lines with 'theta_angle' and 'theta_angle-90' degrees
#minimum length of line segment (wd=n_pix=lol): 15 pixels
#stop("manual test")
k13 <- nrow(B4)
theta_ref <- B4$theta_angle[lnr_ref] #reference line
ro_ref <- B4$ro_pixel[lnr_ref]
theta_ref_ind <- B4$theta_index[lnr_ref] #changed
cat("theta_ref=",theta_ref,"degrees","\n")
setwd(home_dir)
f1 <- paste("./data/",Img_name,"/th_ref_",bnr2,sep="")
save(theta_ref, file=f1) #main direction
alph_ref <- theta_ref - 90
if (alph_ref < 0) { #alph_ref has to be positive
alph_ref <- alph_ref + 180
}
cat("alph_ref=", alph_ref,"degrees","\n")
alph_ref_ind <- alph_ref/theta_step + 1
alph_ref_arc <- alph_ref/omega
theta_ref_arc <- theta_ref/omega
r_max <- plotPar[3]
lol <- 10 # minimum length of line segment [pixels]
i=0
B5_2 <- matrix(nrow=k13,ncol=7)
B5_2[,1:7] <- 0
k1=1
#loop
while (i < k13) {
i <- i + 1
if (B4$theta_angle[i] == theta_ref && B4$n_pixel[i] >= lol || # lol = number of pixels (n_pixel))
B4$theta_angle[i] == alph_ref && B4$n_pixel[i] >= lol) {
B5_2[k1,] <- c(B4$lnr[i],B4$theta_index[i], B4$ro_index[i], B4$n[i], B4$theta_angle[i],B4$ro_pixel[i],B4$n_pixel[i])
k1 <- k1 + 1
}
} #end of loop while
## generalizing, reduction of matrix, conversion to data frame
head(B5_2)
B5_3 <- subset(B5_2,B5_2[,7] >= lol) # length of lines (lol) >= 15 pixels (=1.4 m) (n_pixel)
B5_3
B5_4 <- data.frame(B5_3)
names(B5_4) <- c("lnr", "theta_index", "ro_index", "n", "theta_angle","ro_pixel","n_pixel")
head(B5_4)
B5_4
B5_4_ord <- B5_4[order(B5_4$ro_pixel,decreasing = F),]
k16 <- nrow(B5_4_ord)
row.names(B5_4_ord) <- 1 : k16
B5_4_ord
## check of building outline by means of orthoimage
setwd(OrgImgPathname)
img_ref <- readImage(OrgImgFilename)
img_x_max <- dim(img_ref)[1]
img_y_max <- dim(img_ref)[2]
display(img_ref,method = "raster")
points(pc3$col, pc3$row, pch=20, asp=1, cex=0.2, col="white")
points(xc,yc,pch=3, asp=1, cex=1.0, col="red")
## display of PC and orthoimage in large scale
orig_x<-as.integer(xc - 1.2 * r_max) #r_max is of variable size
orig_y<-as.integer(yc - 1.2 * r_max)
if (orig_x < 0) { #solves problems at edges of orthoimage
orig_x = 0
}
if (orig_y < 0) {
orig_y = 0
}
orig_x
orig_y
wind_x <- as.integer(orig_x + 2.4 * r_max)
wind_y <- as.integer(orig_y + 2.4 * r_max)
if (wind_x > img_x_max) {
wind_x <- img_x_max
}
if (wind_y > img_y_max) {
wind_y <- img_y_max
}
## display enlarged ortho_image and PC of building outline
img_uds <- img_ref[orig_x : wind_x,orig_y:wind_y,1:3]
display(img_uds, method = "raster")
#display(img_uds,method = "browser") #enables zooming
points(xc-orig_x,yc-orig_y,pch=3, asp=1, cex=1.3, col="red")
points(as.integer(pc3$col-orig_x), as.integer(pc3$row-orig_y), pch=20, asp=1, cex=0.2, col="green")
##plot of pixel cloud (PC) in enlarged orthoimage (image-system)
#lnr <- lnr_ref
#lnr <- 94 #change to number of longest lines to be plotted
n_lnr <- lnr_ref
#loop
lnr=lnr_ref
while (lnr <= n_lnr) { #plot of lnr_ref
#browser() #to be used for editing
cat("lnr= ", lnr, "\n")
L_new  <- PC_segment_4(lnr) #change to 'PC_segment_4(i)' if several lines must be plotted
P <- L_new[[1]]
n_P <- L_new[[2]]
P <- P[1:n_P,]
#
P <- as.data.frame(P)
names(P) <- c("idx","x","y")
P_red <- reduce_pointset(P) #new
head(P_red)
x_m <- mean(P_red[,2])
y_m <- mean(P_red[,3])
points((P_red[,2]-orig_x),(P_red[,3]-orig_y), pch=".", asp=1, cex=1.0, col="blue") #see 'Plots' (plot)
points(x_m-orig_x, y_m-orig_y, pch=16, asp=1, cex=1.0, col="red")
lnr <- lnr + 1
} #end loop while
# check of building outline by means of orthoimage (small scale)
setwd(OrgImgPathname)
img_ref <- readImage(OrgImgFilename)
img_x_max <- dim(img_ref)[1]
img_y_max <- dim(img_ref)[2]
display(img_ref,method = "raster")
#display(img_ref) #plot in browser-mode
points(pc3$col, pc3$row, pch=20, asp=1, cex=0.2, col="white")
points(xc,yc,pch=3, asp=1, cex=1.5, col="red")
#window
fr <- matrix(nrow=5, ncol=2)
orig_y <- abs(orig_y)
fr[1,1] <- orig_x
fr[1,2] <- orig_y
fr[2,1] <- wind_x
fr[2,2] <- orig_y
fr[3,1] <- wind_x
fr[3,2] <- wind_y
fr[4,1] <- orig_x
fr[4,2] <- wind_y
fr[5,1] <- orig_x
fr[5,2] <- orig_y
#
lines(fr, type="l", asp=1, lwd=2, lty=1, col="yellow")
#plot of ref line in orthoimage (small scale)
theta_math <- 180 - B4$theta_angle[lnr_ref]
theta_math #theta_ref_math
B4
#plot of ref line in orthoimage (small scale)
theta_math <- 180 - B4$theta_angle[lnr_ref]
theta_math #theta_ref_math
