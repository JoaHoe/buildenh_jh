while (i <= n_lnr){
j <- 1
while (j <= np) {
if (B5_6_cor2$lnr[i] == B4$lnr[j]) {
B5_6_cor2[i,2:7] <- B4[j,2:7]
} #end if
j <- j+1
} #end loop j
i <- i+1
} #end loop i
B5_6_cor2 #B without sequence of PC
B5_6 <- B5_6_cor2
B5_6
B5_6[,8] <- 0
names(B5_6)[8] <- "ortho"
len <- length(B5_6$ortho)
vec <- 1 : len
#loop
for (i in vec) {
if (B5_6$theta_angle[i] == theta_ref || B5_6$theta_angle[i] == alph_ref) {
B5_6$ortho[i] <- 1
}
} #end i-loop
B5_6
#parameter for line-sequence
min_pixel <- min(B5_6$n_pixel)
bn_PC <- nrow(B5_6)
with_northo <- sum(B5_6$ortho)/length(B5_6$ortho)
soph <- 1 #sequence is difficult to determine
#Output of case ("100_all+nonortho")
setwd(home_dir)
fname9 <- paste("./data/",Img_name,"/b",bnr2,"_case.txt", sep="")
write.table(cas,fname9,row.names = FALSE, col.names = FALSE)
} #end cas="100_all+nonortho"
if (cas == "extr_wd") {
B5_6 <- B5_4e3_4extr
}
if (cas == "4_long") {
B5_6 <- B5_4e_4long2
}
if (cas == "100_all") {
B5_6 <- B5_6R4
}
if (cas == "100_all+nonortho") {
B5_6 <- B5_6
}
B5_6
row.names(B5_6) <- 1 : length(B5_6$lnr)
lnr_det7 <- B5_6$lnr
lnr_det7
## Derivation of PCs and plotting of detected line segments
theta<-seq(0,175, by=theta_step)
theta_rad <- theta/omega
##plot of selected lines
par(mai = c(1.02,0.82,0.82,0.42)) #setup of margins/plot region [inches]
par('usr')
x <- xc
y <- yc
r_max2 <- 1.1 * r_max
mar <- 100
plot(x,-y, pch=3, cex=2, col="red", asp=1, xlim=c(xc - r_max2,xc + r_max2),
ylim=c(-(yc + r_max2),-(yc - r_max2)), ann = TRUE, axes = TRUE,
main=paste("b ",bnr2, sep=("")))
points(pc3$col, -pc3$row, pch=20, asp=1, cex=0.5, col="red")
points(xc-mar,-(yc+mar), pch=3, asp=1, cex=2, col="red")
points(xc+mar,-(yc+mar), pch=3, asp=1, cex=2, col="red")
points(xc-mar,-(yc-mar), pch=3, asp=1, cex=2, col="red")
points(xc+mar,-(yc-mar), pch=3, asp=1, cex=2, col="red")
#loop PC plotting
lnr_det7
n_lnr7 <- length(lnr_det7)
centers_PC <- matrix(nrow=n_lnr7, ncol=4)
centers_PC[,] <- 0
centers_PC
vec <- 1 : n_lnr7
#loop
n=1
for (n in vec) {
#browser() #with interaction?
lnr <- lnr_det7[n]
cat("lnr= ",lnr,"\n")
PC_seg_P_nP <- PC_segment_4(lnr) #call of function
P <- PC_seg_P_nP[[1]]
n_P <- PC_seg_P_nP[[2]]
P <- as.data.frame(P)
names(P) <- c("idx","x","y")
P_red <- reduce_pointset(P) #new
head(P_red)
x_m <- mean(P_red[,2])
y_m <- mean(-P_red[,3])
points(x_m, y_m, pch=20, asp=1, cex=1.5, col="blue")
centers_PC[n,1] <- lnr
centers_PC[n,2] <- x_m
centers_PC[n,3] <- y_m
centers_PC[n,4] <- n_P
} #end of for-loop
centers_PC
#plot of approximate lines into graph
n_9 <- length(B5_6$lnr)
len <- 1 : n_9
B5_6
row.names(B5_6) <- 1 : n_9
B5_6$ortho <- 0
#loop
for (i in len) {
if (B5_6$theta_angle[i] == theta_ref || B5_6$theta_angle[i] == alph_ref) {
B5_6$ortho[i] <- 1
} else {
B5_6$ortho[i] <- 0
} #end else-if
} #end for-loop
#B5_6[8,6] <- 255
B5_6
#loop for plotting into graph
n1=1
for (n1 in len) {
cat("PC_nr=", B5_6$lnr[n1], "\n")
#browser()
theta_angle <- B5_6$theta_angle[n1]
theta_math <- (180 - theta_angle) #theta of oriented line
x <- centers_PC[n1,2]
y <- centers_PC[n1,3]
p2<- round(x * cos(theta_math/omega) + y * sin(theta_math/omega))
cat("p2= ",p2,"\n")
a <- -1/tan(theta_math/omega)
b <- round(p2/sin(theta_math/omega))
coef = c(b,a)
if (is.finite(a)) {
abline(coef, col="green", lty=1, lwd=2, asp=1)
}
} # end loop
##plot approximate lines onto orthoimage (large scale) (old)
B5_6
par(mai = c(1.02,0.82,0.82,0.42)) #setup of margins/plot region [inches]
display(img_uds, method = "raster")
#display(img_uds, method = "browser")
points(xc-orig_x,yc-orig_y,pch=3, asp=1, cex=1.3, col="blue")
points(as.integer(pc3$col-orig_x), as.integer(pc3$row-orig_y), pch=20, asp=1, cex=0.3, col="green")
#plot approximate lines onto orthoimage (small and large scale)
B5_6
len
orig_x
orig_y
#display orthoimage in small scale
display(img_ref,method = "raster")
#display(img_ref,method = "browser")
points(pc3$col, pc3$row, pch=20, asp=1, cex=0.5, col="green")
points(xc, yc, pch=3, asp=1, cex=1.5, col="red")
#window
fr <- matrix(nrow=5, ncol=2)
orig_y <- abs(orig_y)
fr[1,1] <- orig_x
fr[1,2] <- orig_y
fr[2,1] <- wind_x
fr[2,2] <- orig_y
fr[3,1] <- wind_x
fr[3,2] <- wind_y
fr[4,1] <- orig_x
fr[4,2] <- wind_y
fr[5,1] <- orig_x
fr[5,2] <- orig_y
#
lines(fr, type="l", asp=1, lwd=2, lty=1, col="yellow")
#loop
n1=1
len
for (n1 in len) {
cat("PC_nr=", B5_6$lnr[n1], "\n")
#browser()
theta_angle <- B5_6$theta_angle[n1]
theta_math <- (180 - theta_angle) #theta of oriented line
x <- centers_PC[n1,2]
y <- centers_PC[n1,3]
p2<- round(x * cos(theta_math/omega) + y * sin(theta_math/omega))
a <- -1/tan(theta_math/omega)
b <- round(p2/sin(theta_math/omega))
#change to image-system
a <- (-a)
b <- (-b)
#plot
coef <- c(b,a)
if (is.finite(a)) {
abline(coef, col="blue", lty=1, lwd=2, asp=1)
}
} #end for-loop (small scale)
##plot approximate lines onto orthoimage (large scale)
display(img_uds, method = "raster")
#display(img_uds, method = "browser")
points(xc-orig_x,yc-orig_y,pch=3, asp=1, cex=1.3, col="red")
points(as.integer(pc3$col-orig_x), as.integer(pc3$row-orig_y), pch=20, asp=1, cex=0.3, col="green")
# loop
len
n1=1
for (n1 in len) {
cat("PC_nr=", B5_6$lnr[n1], "\n")
#browser()
theta_angle <- B5_6$theta_angle[n1]
theta_math <- (180 - theta_angle) #theta of oriented line
x <- centers_PC[n1,2]
y <- centers_PC[n1,3]
points(x-orig_x,-(y-orig_y_math),pch=18, asp=1, cex=1.3, col="red")
#calculation of p2 in math-system with oriented line
p2 <- round(x*cos(theta_math/omega) + y*sin(theta_math/omega)) #math-system
a <- -1/tan(theta_math/omega)
b <- round(p2/sin(theta_math/omega))
#calculation of intercept for image extract (math_system)
y1_math <- a * orig_x + b
y1_math <- round(y1_math) #change to math-system
orig_y_math <- (-orig_y) #change to math_system
b2 <- y1_math - orig_y_math
#change to img-system
a_img <- -a
b2_img <- (-b2)
# plot
coef2 <- c(b2_img,a_img)
if (is.finite(a)) {
abline(coef2, col="white", lty=1, lwd=2, asp=1)
}  else {
ro_l1 <- B4$ro_pixel[lnr]
ro_l2 <- ro_l1 + ro_1
ro_l3 <- round(ro_l2 - orig_x)
lines(c(ro_l3,ro_l3),c(0, (wind_y - orig_y)),col="white")
} #end if-else
} #end of loop
#output
bnr2
setwd(home_dir)
f3 <- paste("./data/",Img_name,"/unsorted_lines_b",bnr2,".txt",sep="")
B5_6
write.table(B5_6,f3)
# Storage in a list (all_lines)
n_lnr <- nrow(B5_6)
PC_nr <- B5_6$lnr[1:n_lnr]
n_PC <- n_lnr
vec_x <- 1 : n_PC
## general solution for list
all_lines <- list()
for (i in vec_x) {
all_lines[[i]] <- "PC"
}
for (i in vec_x) {
all_lines[i] <- paste("P",i,sep="")
}
##loop for reading all point clusters (PCs)
par(mai = c(1.02,0.82,0.82,0.42)) #setup of margins/plot region [inches]
x <- xc
y <- yc
r_max2 <- 1.1*r_max
plot(x,-y, pch=3, cex=2, col="red", asp=1,
xlim=c(xc-r_max2,xc+r_max2), ylim=c(-(yc+r_max2),-(yc-r_max2)),
main=paste("b ",bnr2, sep=("")), axes=TRUE) #large scale
points(pc3$col, -pc3$row, pch=20, asp=1, cex=0.5, col="orange")
cat("line numbers (not in correct sequence):","\n")
print(PC_nr)
palette2 <- c("brown", "red", "gray",  "darkgreen", "blue", "magenta", "black", "cyan")
setwd(home_dir)
k=1
i=1
#loop
for (i in PC_nr){
lnr <- i
#browser()
cat("lnr=",lnr,"\n")
fname=paste("./data/",Img_name,"/b",bnr2,"_",lnr,".txt", sep="")
P0 <- read.table(fname, col.names=c("idx","x","y"))
nrow <- nrow(P0)
cat("nrow=",nrow,"\n")
P0_red <- reduce_pointset(P0) #correction for gaps using histogram analysis
nrow <- length(P0_red$idx)
all_lines[[k]] <- P0_red
#points(P0_red[,2],-P0_red[,3], pch='.', asp=1, cex=2, col=palette2[k])
points(P0_red[,2],-P0_red[,3], pch='.', asp=1, cex=2, col="green")
k=k+1
} #end loop
## Convert 'all_lines' (matrix) to 'all_PC' (list)
all_PC <- all_lines
names_PC <- list()
n_PC <- length(PC_nr)
vec_x <- 1:n_PC
for (i in vec_x) {
names_PC[[i]] <- "PCN"
}
#loop
k=1
i=1
for (i in PC_nr) {
na_PC<-paste("PC_",PC_nr[k],sep="")
name_PC <- as.name(na_PC)
names_PC[[k]] <- name_PC
k <- k+1
} #end of for-loop
names_PC
names(all_PC) <- names_PC
## plot image detail
display(img_uds, method = "raster")
#palette1 = c("white", "red", "yellow", "green", "blue", "magenta", "black", "cyan")
n_x <- length(PC_nr)
vec_y <- 1 : n_x
#loop
i=1
for (i in vec_y) {
cat("i=",i,"\n")
#browser()
points((all_PC[[i]]$x - orig_x),(all_PC[[i]]$y - orig_y),
pch='.', asp=1, cex=2, col = "green")
points(xc-orig_x,yc-orig_y,pch=3, asp=1, cex=1.3, col="red")
x <- centers_PC[i,2]
y <- centers_PC[i,3]
points(x-orig_x,-(y-orig_y_math),pch=18, asp=1, cex=1.3, col="red")
} #end for-loop
#loop
setwd(home_dir)
for (i in vec_y) {
fname8 <- paste("./data/",Img_name,"/all_PC$PC_nr",PC_nr[i],".txt",sep="")
write.table(all_PC[[i]], fname8)
} #end loop output of list PC_all
all_PC
cat("end of program 'line-detection.R' - continue with 'sequence_of_lines.R' ","\n")
setwd(home_dir2)
source(paste("sequence_of_lines_v",v_nr,".R",sep=""))
source("C:/Users/Joachim/R_programs/buildenh_jh/clone1/R/line_detection_v1.1.R")
##name of program (script): 'line_detection.R'
cat("version_number= ",v_nr,"\n")
#description: separation of pixel clusters (PC) representing line segments
#detecting of lines representing the selected object
#author: Joachim Hoehle
#examples: ISPRS dataset 'Vaihingen', orthoimages #7, #1
#instructions: check the ro-range and the main direction of object
#the minimum lengths of the lines to be detected are defined by a default value (n_pix)
#the default value (n_pix) may be adapted to the existing objects of the orthoimage
#use 'Zoom' for evaluation of position
#change eventually the default value for each object type ("extr_wd", "4_long", "100_all", "100_all+nonortho")
#GNU General Public License (GPL)
cat("#########################################################################","\n")
cat("start of program 'line_detection.R'","\n")
setwd(home_dir)
##parameter
omega=180/pi #factor to convert from radiant to degree
k=1.64 #approximate scale factor for length of line segment (empirically determined)
options(digits = 8)
##input
setwd(home_dir)
f1=paste("./data/",Img_name,"/idxy_LCM_b",bnr2,".csv",sep="")
pc2<-read.table(f1, header=TRUE) #land cover map
head(pc2)
names(pc2)[1]<-"col"
names(pc2)[2]<-"row"
length(pc2$row)
nrow<-length(pc2$col)
##input plot-parameter
f1<-paste0("./data/",Img_name,"/param_b_", bnr2, sep = "", collapse = NULL)
load(f1)
xc <- plotPar[1]
yc <- plotPar[2]
r_max <- plotPar[3]
alpha <- plotPar[4] #approximage angle of ellipse' main axis
alpha_math <- (-alpha) #change to math-system
## extreme coordinates
max(pc2$col)
max(pc2$row)
min(pc2$col)
min(pc2$row)
#plot in small scale (image #7)
x = 0; y = 0 #origo
if (Img_name == "ISPRS7") {
plot(x,-y, pch=3, cex=2, col="black", asp=1, xlim=c(0,1887), ylim=c(-2557, 1000), main=paste("b",bnr2))
}
if (Img_name == "ISPRS1") {
plot(x,-y, pch=3, cex=2, col="black", asp=1, xlim=c(0,1919), ylim=c(-2569, 1000))
}
points(xc,-yc, pch=3, cex=1.5, col="red", asp=1) #centre of PC
points(pc2$col,-pc2$row, pch=".", cex=1.5, col="blue", asp=1) #PC
#plot of graph in large scale
par(mai = c(1.02,0.82,0.82,0.42)) #setup of margins/plot region [inches]
r_max2 <- 1.1*r_max
plot(xc,-yc, pch=3, cex=3, col="red", asp=1, xlim=c(xc-r_max2,xc+r_max2),
ylim=c(-yc-r_max2,-yc+r_max2), xlab="col", ylab="row", main=paste("b",bnr2))
points(xc,-yc, pch=3, cex=1.5, col="red", asp=1) #centre of PC
points(pc2$col,-pc2$row, pch=".", cex=1.5, col="blue", asp=1) #PC
#resolution of Hough matrix:
theta_step <- 5 #step in angle [degrees]
cat("step in angle (theta)=",theta_step,"degrees","\n")
ro_step <- 5 #step in distance [pixel]
cat("step in distance (ro)=",ro_step,"pixel","\n")
#extreme coordinates
(X_min=min(pc2$col))
(Y_min=min(pc2$row))
(X_max=max(pc2$col))
(Y_max=max(pc2$row))
##range of ro (Dis_min, Dis_max)
Dis_min <- sqrt(X_min^2+Y_min^2)
Dis_min <- as.integer(Dis_min)
Dis_max <- sqrt(X_max^2+Y_max^2)
Dis_max <- as.integer(Dis_max)
#range of angle
theta <- seq(0,175, by=theta_step)
n_theta<-length(theta)
cat("manual input required","\n")
ro_rg = 2 #default value:1
ro_rg <- as.integer(ro_rg)
cat("selected ro-range type=", ro_rg,"\n")
#
if(ro_rg == 0) {
ro <- seq(Dis_min,Dis_max,by=ro_step) #first solution of theta_ref
n_ro <- length(ro)
ro_1 <- ro[1]
ro[n_ro]
setwd(home_dir)
save(theta_step, ro_step, ro, ro_1, n_theta, n_ro, ro_rg, file="H_par") #storage
} #end ro_rg=0
if (ro_rg == 1) { # 1 is default value
ro <- seq(0, Dis_max, by=ro_step) #second solution of theta_ref
n_ro <- length(ro)
ro_1 <- ro[1]
ro[n_ro]
#storage of Hough parameters
setwd(home_dir)
save(theta_step, ro_step, ro, ro_1, n_theta, n_ro, ro_rg,
file = paste("./data/",Img_name,"/H_par", sep="", collapse=NULL))
} #end of ro_rg = 1
if(alpha_math < 0){
alpha_math <- 180 + alpha_math
}
theta_appr <- alpha_math - 90
d_safety = 0 #safety value in [pel]
theta1 <- theta_appr
theta1_arc <- theta1/omega
theta2 <- theta1 + 90
theta2_arc <- theta2/omega
alpha_rad <- alpha/omega
max(pc2$col)
max(pc2$row)
min(pc2$col)
min(pc2$row)
X <- max(pc2$col)
Y <- (-max(pc2$row)) #change to math-system
ro1_max <- cos(theta1_arc) * X + sin(theta1_arc) * Y
#ro1_max <- abs(ro1_max)
ro2_max <- cos(theta2_arc) * X + sin(theta2_arc) * Y
#ro2_max <- abs(ro2_max)
X <- min(pc2$col)
Y <- (-min(pc2$row)) #change to math-system
ro1_min <- cos(theta1_arc) * X + sin(theta1_arc) * Y
#ro1_min <- abs(ro1_min)
ro2_min <- cos(theta2_arc) * X + sin(theta2_arc) * Y
#ro2_min <- abs(ro2_min)
ro_range <- c(ro1_max, ro2_max, ro1_min, ro2_min)
ro_range
max_ro <- as.integer(max(ro_range))
min_ro <- as.integer(min(ro_range))
min_ro2 <- as.integer(min_ro - d_safety)
max_ro2 <- as.integer(max_ro + d_safety)
ro <- seq(min_ro2,max_ro2,by=ro_step)
ro
source("C:/Users/Joachim/R_programs/buildenh_jh/clone1/R/startup_buildenh_v1.1.R")
B2
#
print(intsec_linepair_vertex_coord)
25*1.64
#B2 <- subset(B1,B1[,3] >= 80) # ~56*k, K ~ 1.64 (k is determined empirically)
#B2 <- subset(B1,B1[,3] >= 57) # ~35*k, K ~ 1.64 (k is determined empirically)
B2 <- subset(B1,B1[,3] >= 41) # ~25*k, K ~ 1.64 (k is determined empirically)
nrow(B2)
head(B2)
max(B2[,1], na.rm = FALSE) #theta_index
min(B2[,1], na.rm = FALSE) #theta_index
dim(B2)
b_v <- as.numeric(B2[,1])
vbr <- 1 : 36
##histogram
hn <- hist(b_v, breaks=vbr) ##plot of histogram b_v
##test for existence of main ortho-lines
theta_ref_ind <- B2[1,1]
ro_rg = 2 #default value:1
mode(ro_rg)
source("C:/Users/Joachim/R_programs/buildenh_jh/clone1/R/startup_buildenh_v1.1.R")
source("C:/Users/Joachim/R_programs/buildenh_jh/clone1/R/startup_buildenh_v1.1.R")
#plot graph
alpha <- alpha_math
alpha_arc <- alpha/omega
a = tan(alpha_arc)
theta_ang <- alpha + 90
theta_arc <- theta_ang/omega
ro_0 <- cos(theta_arc) * xc + sin(theta_arc) * (-yc)
b <- ro_0/(cos(alpha_arc))
coef <- c(b,a)
if(is.finite(b)){
abline(coef, col="green", lty=1, lwd=2, asp=1)
} else {
ro_l1 <- ro_0
lines(c(ro_l1,ro_l1),c(0,-2500))
} #end if-else
source("C:/Users/Joachim/R_programs/buildenh_jh/clone1/R/startup_buildenh_v1.1.R")
B2
library(knitr)
install.packages("knitr")
source("C:/Users/Joachim/R_programs/buildenh_jh/clone1/R/startup_buildenh_v1.1.R")
##start the next program ("enhance_image.R")
setwd(home_dir2)
source(paste("enhance_image_v",v_nr,".R",sep=""))
#author: Joachim Hoehle
#instructions: change directories for input;
#instructions: input project title and image name
#instructions: save your home directory
#instructions: type 'Ctrl+A'(select all) and 'Source'
#instructions: new users may start by examples (processing mode = demo)
#depends: R-4.2.1
#Copyright(C) 2022 Joachim Hoehle
#GNU General Public License (GPL)
###################################################################################
cat("start of software package 'buildenh_jh' ","\n")
source("C:/Users/Joachim/R_programs/buildenh_jh/clone1/R/startup_buildenh_v1.1.R")
